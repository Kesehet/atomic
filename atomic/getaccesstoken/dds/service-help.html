<h1>Fluent Function</h1>

<p>
Fluent Functions provide server side function event handlers for a variety of form event triggers. 
</p>

<p>
The Fluent Function programming interface it the same across a variety of function triggers enabling you to re-uses function code in a 
variety of contexts. For example you could a single function for doing both data pre-fill when a form is first opened and also when a saved 
form is resumed.
</p>

<h3>DDS configuration</h3>

<p>
The DDS access-token flow expects configuration and account data that determine which accounts are sent to Atomic:
</p>

<ul>
  <li><strong>Routing number</strong>: set the Config Service key
  <code>routingNumber</code> (see <code>FnbBaseSvc.CONFIG_SERVICE_KEY_ROUTING_NUMBER</code>).
  This value is applied to every account sent in the access-token request.</li>
  <li><strong>DDS-eligible products</strong>: only consumer deposit products that are marked
  <code>IsEligibleForDDS</code> in the configured product catalog are included. The service ignores
  non-eligible products.</li>
  <li><strong>Existing account constraints</strong>: existing accounts are included only when their
  <code>productIdent</code> matches a DDS-eligible product id and the account status is
  <code>Active</code> (or has no status).</li>
  <li><strong>Allowed account types</strong>: existing accounts map Fiserv account types to Atomic
  types as follows: <code>DDA</code> → <code>checking</code>, <code>SDA</code> → <code>savings</code>.
  New products use the product type (lowercased) as the Atomic account type.</li>
</ul>

<h3>Function API</h3>

<p>
Fluent Functions all have the same programming interface taking a 
<a target="_blank" href="../../help/javadoc-fluent/com/avoka/tm/func/FuncParam.html">FuncParam</a> parameter and returning a
<a target="_blank" href="../../help/javadoc-fluent/com/avoka/tm/func/FormFuncResult.html">FormFuncResult</a> object.
</p>

<pre class="prettyprint">class FluentFunction {

    FuncResult invoke(FuncParam param) {

        // Business logic...

        FormFuncResult result = new FormFuncResult()

        return result
    }
} </pre>

<h4>Function Param</h4>

<p>
The param FuncParam object provides the set of inputs for the function's execution. All the function inputs are immutable with the 
exception of the appDoc XML Document. Making changes to the XML Document will be persisted after all the functions have been
executed. If a function throws an exception however changes to the XML Document will not be stored.
</p>

<pre class="prettyprint">class FuncParam {

    // The function trigger
    final String trigger
    
    // The mutable XML application document
    final Document appDoc
  
    // The request parameters
    final Map<String, Object> params
   
    // The HTTP request
    final HttpServletRequest request

    // The service definition
    final SvcDef svcDef

    // The transaction
    final Txn txn
   
    // The user
    final User user
} </pre>

<h4>Function Result</h4>

<p>
The FormFuncResult return object provides the output information used by the system to implement its behavior.
</p>

<pre class="prettyprint">class FormFuncResult {

    // Specify whether to continue processing remaining functions
    boolean continueProcessing = true
  
    // Specify any result data
    final Map<String, Object> data = new TreeMap()
  
    // Include XML formData in response
    boolean includeFormData = false
  
    // Specify validation errors to be returned to the form
    final List&lt;ValidationError&gt; errors = new ArrayList&lt;&gt;()
  
    // Redirect the end user to another location (optional)
    String redirectUrl
} </pre>

<p>
Each of the result object fields provide specific instructions for the system behavior. These include:
</p>

<dl class="service-listing padded">

<dt><code>continueProcessing</code></dt>
<dd>
The  flag specifies whether any functions to be executed after this function should be run. 
This provides your function the ability to abort further process an return any validation errors immediately back to the user.
Please note any application transaction changes will be persisted to the database.
</dd>

<dt><code>data</code></dt>
<dd>
The data field provides a map of result values which will be returned to the Maestro form as a JSON object under the attribute name:
<code>data</code>
</dd>

<dt><code>includeFormData</code></dt> 
<dd>
The  flag specifies whether the XML form data Document should be returned to the Maestro form as a JSON attribute under the name:
<code>formData</code>
</dd>

<dt><code>errors</code></dt> 
<dd>
The errors field provides a array of 
<a target="_blank" href="../../help/javadoc-fluent/com/avoka/tm/func/ValidationError.html">ValidationError</a> 
values to be returned to the Maestro form as JSON array under the attribute name: <code>errors</code>. Generally if a Fluent Function
returns errors, any application transaction changes will still be persisted to the database. The exception however is if the user
performs a "User Submit" operation, in this case if a function returns any errors the application transaction will be rolled back, and
any changes to the application will be reverted. This to ensure the application remains in a consistent state.
</dd>

<dt><code>redirectUrl</code></dt> 
<dd>
The redirectUrl field specifies that the URL that the users browser should be redirected. This value is returned to the Maestro form
as a JSON attribute with the name: <code>redirectUrl</code>
</dd>

</dl>


<h3>Function Triggers</h3>

<p>
Fluent Functions can be triggered on a variety of form events including:
</p>

<table class="script-parameters">
<tr>
  <th>Trigger Type</th> 
  <th>Description</th>
</tr>
<tr>
  <td class="paramName">Form Open</td> 
  <td>
  Called when new form transaction is created, immedately before it is rendered to the browser.
  This event trigger is initated by the TM server.
  </td>
</tr>
<tr>
  <td class="paramName">Form Resume</td> 
  <td>
  Called when a saved form transaction is resumed, immediately before it is rendered to the browser.
  This event trigger is initated by the TM server.
  </td>
</tr>
<tr>
  <td class="paramName">Form Update</td> 
  <td>
  Called when the form makes an background update operation. 
  This event trigger is initiated by the Maestro Form in the browser.
  </td>
</tr>
<tr>
  <td class="paramName">Form Ineligible</td> 
  <td>
  Called when the form determines the user is inelligible to complete the application. 
  This event trigger is initated by the Mastro Form business rule scripts in the browser after determining the user is not eligible to
  complete the application.
  </td>
</tr>
<tr>
  <td class="paramName">Form Function</td> 
  <td>
  Called by Mastro Form business rule scripts generally to get dynamic data from the server and perform any transaction updates. 
  This event trigger is initated by the Mastro Form business rule scripts in the browser.
  </td>
</tr>
<tr>
  <td class="paramName">User Save</td> 
  <td>
  Called when the user explicity saves and closes the form. 
  This event trigger is initated by the user of the Maestro Form in the browser.
  </td>
</tr>
<tr>
  <td class="paramName">User Submit</td> 
  <td>
  Called when the user explicity submits a completed form application. 
  This event trigger is initated by the user of the Maestro Form in the browser. 
  </td>
</tr>
<tr>
  <td class="paramName">User Cancel</td> 
  <td>
  Called when the user explicity cancels and closes a form application.
  This event trigger is initated by the user of the Maestro Form in the browser. 
  </td>
</tr>
</table>

<p>
To configure Form Function Triggers you can do this either in the Management Console via the Form Version Functions tab.
</p>

<img class="screen-grab" src="/manager/admin/help/images/function-triggers.png" alt="Form Function Configuration" >

<p>
Form Functions can also be configured by editing an Application Package <code>form-def.json</code> file in a developers workspace.
</p>

<pre class="prettyprint"> {
    "name": "Credit Card Application",
    ...
    "formVersions": [{
        "versionNumber": "1.0",
        ...
        "formFunctions": [
            {
                "trigger": "Form Open"
                "name": "Data Loader",
                "version": "1.0.1",
                "sequence": 1
            },
            {
                "trigger": "Background Delivery"
                "name": "Application Delivery",
                "version": "1.0.0",
                "sequence": 1
            }
        ]
        ...
    ]
} </pre>


<h3>Exception Handling</h3>

<p>
The Journey Manager error handing for Fluent Function which throw exceptions is listed below.
</p>

<table class="script-parameters">
<tr>
  <th>Trigger Types</th> 
  <th>Exception Handling</th>
</tr>
<tr>
  <td class="paramName">
    Form Open <br/>
    Form Resume
  </td> 
  <td>
  Functions throwing an exception will cause the form rendering to be aborted and an error page will be displayed to the user.
  <br/>
  The error will be logged with the Groovy Service Log record.  
  </td>
</tr>
<tr>
  <td class="paramName">
      Form Function <br/>
  </td> 
  <td>
      Functions throwing an exception will cause HTTP 500 response to be returned to the browser with the error key <code>stdErrs.systemError</code>.
      <br/>
      The root cause exception will be logged to the Error Log and associated Groovy Service Log.
  </td>
</tr>
<tr>
  <td class="paramName">
      Form Update <br/>
      Form Ineligible <br/>
      User Save <br/>
      User Submit <br/>
      User Cancel
  </td> 
  <td>
      Functions throwing an exception will cause HTTP 500 response to be returned to the browser with the error key <code>stdErrs.systemError</code>.
      <br/>
      The root cause exception will be logged to the Error Log and associated Groovy Service Log.
      <br/>
      The database transaction associated with this command will be rolled back and any application updates will be reverted. 
  </td>
</tr>
</table>
